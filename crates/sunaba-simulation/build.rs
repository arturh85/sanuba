//! Build script to auto-generate MaterialName enum from MaterialId constants
//!
//! This parses src/materials.rs and generates a type-safe enum that can be used
//! in scenario files instead of raw numeric IDs.

use std::env;
use std::fs;
use std::io::Write;
use std::path::Path;

fn main() {
    println!("cargo:rerun-if-changed=src/materials.rs");

    let materials_src =
        fs::read_to_string("src/materials.rs").expect("Failed to read src/materials.rs");

    let materials = parse_material_ids(&materials_src);

    let out_dir = env::var("OUT_DIR").expect("OUT_DIR not set");
    let out_path = Path::new(&out_dir).join("material_enum.rs");

    let generated = generate_enum(&materials);

    let mut file = fs::File::create(&out_path).expect("Failed to create output file");
    file.write_all(generated.as_bytes())
        .expect("Failed to write output file");
}

/// A parsed material constant
struct MaterialConst {
    /// Original name (e.g., "SAND", "SOAPY_WATER")
    name: String,
    /// The numeric ID
    id: u16,
}

/// Parse all `pub const NAME: u16 = ID;` lines from MaterialId impl block
fn parse_material_ids(source: &str) -> Vec<MaterialConst> {
    let mut materials = Vec::new();
    let mut in_impl_block = false;

    for line in source.lines() {
        let trimmed = line.trim();

        // Detect start of impl MaterialId block
        if trimmed.starts_with("impl MaterialId") {
            in_impl_block = true;
            continue;
        }

        // Detect end of impl block
        if in_impl_block && trimmed == "}" {
            break;
        }

        // Parse const declarations within the impl block
        if in_impl_block
            && trimmed.starts_with("pub const")
            && let Some(mat) = parse_const_line(trimmed)
        {
            materials.push(mat);
        }
    }

    materials
}

/// Parse a single const line like `pub const SAND: u16 = 2;`
fn parse_const_line(line: &str) -> Option<MaterialConst> {
    // Remove "pub const " prefix
    let rest = line.strip_prefix("pub const ")?;

    // Find the colon separating name from type
    let colon_pos = rest.find(':')?;
    let name = rest[..colon_pos].trim().to_string();

    // Find the equals sign
    let equals_pos = rest.find('=')?;

    // Extract the ID (everything after = until ; or //)
    let after_equals = &rest[equals_pos + 1..];
    let id_str = after_equals.split(';').next()?.split("//").next()?.trim();

    let id: u16 = id_str.parse().ok()?;

    Some(MaterialConst { name, id })
}

/// Convert SCREAMING_SNAKE_CASE to PascalCase
fn to_pascal_case(s: &str) -> String {
    s.split('_')
        .map(|part| {
            let mut chars = part.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => {
                    first.to_uppercase().collect::<String>() + &chars.as_str().to_lowercase()
                }
            }
        })
        .collect()
}

/// Generate the complete enum module
fn generate_enum(materials: &[MaterialConst]) -> String {
    let mut out = String::new();

    // Header
    out.push_str("// Auto-generated by build.rs - DO NOT EDIT\n");
    out.push_str("// This file is generated from MaterialId constants in materials.rs\n\n");

    out.push_str("use serde::{Deserialize, Serialize, Deserializer, Serializer};\n");
    out.push_str("use std::str::FromStr;\n\n");

    // Enum definition
    out.push_str("/// Material names for use in scenario files and APIs\n");
    out.push_str("///\n");
    out.push_str("/// This enum is auto-generated from MaterialId constants.\n");
    out.push_str("/// Use this instead of raw numeric IDs for type safety.\n");
    out.push_str("#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n");
    out.push_str("#[repr(u16)]\n");
    out.push_str("pub enum MaterialName {\n");

    for mat in materials {
        let pascal = to_pascal_case(&mat.name);
        out.push_str(&format!("    {} = {},\n", pascal, mat.id));
    }

    out.push_str("}\n\n");

    // From<MaterialName> for u16
    out.push_str("impl From<MaterialName> for u16 {\n");
    out.push_str("    fn from(name: MaterialName) -> u16 {\n");
    out.push_str("        name as u16\n");
    out.push_str("    }\n");
    out.push_str("}\n\n");

    // TryFrom<u16> for MaterialName
    out.push_str("impl TryFrom<u16> for MaterialName {\n");
    out.push_str("    type Error = u16;\n\n");
    out.push_str("    fn try_from(id: u16) -> Result<Self, Self::Error> {\n");
    out.push_str("        match id {\n");

    for mat in materials {
        let pascal = to_pascal_case(&mat.name);
        out.push_str(&format!(
            "            {} => Ok(MaterialName::{}),\n",
            mat.id, pascal
        ));
    }

    out.push_str("            _ => Err(id),\n");
    out.push_str("        }\n");
    out.push_str("    }\n");
    out.push_str("}\n\n");

    // Display
    out.push_str("impl std::fmt::Display for MaterialName {\n");
    out.push_str("    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n");
    out.push_str("        match self {\n");

    for mat in materials {
        let pascal = to_pascal_case(&mat.name);
        let lower = mat.name.to_lowercase();
        out.push_str(&format!(
            "            MaterialName::{} => write!(f, \"{}\"),\n",
            pascal, lower
        ));
    }

    out.push_str("        }\n");
    out.push_str("    }\n");
    out.push_str("}\n\n");

    // FromStr
    out.push_str("impl FromStr for MaterialName {\n");
    out.push_str("    type Err = String;\n\n");
    out.push_str("    fn from_str(s: &str) -> Result<Self, Self::Err> {\n");
    out.push_str("        match s.to_lowercase().as_str() {\n");

    for mat in materials {
        let pascal = to_pascal_case(&mat.name);
        let lower = mat.name.to_lowercase();
        out.push_str(&format!(
            "            \"{}\" => Ok(MaterialName::{}),\n",
            lower, pascal
        ));
    }

    out.push_str("            _ => Err(format!(\"Unknown material name: '{}'. Valid names: air, stone, sand, ...\", s)),\n");
    out.push_str("        }\n");
    out.push_str("    }\n");
    out.push_str("}\n\n");

    // Serde Serialize (as lowercase string)
    out.push_str("impl Serialize for MaterialName {\n");
    out.push_str("    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n");
    out.push_str("    where\n");
    out.push_str("        S: Serializer,\n");
    out.push_str("    {\n");
    out.push_str("        serializer.serialize_str(&self.to_string())\n");
    out.push_str("    }\n");
    out.push_str("}\n\n");

    // Serde Deserialize (from string or number)
    out.push_str("impl<'de> Deserialize<'de> for MaterialName {\n");
    out.push_str("    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n");
    out.push_str("    where\n");
    out.push_str("        D: Deserializer<'de>,\n");
    out.push_str("    {\n");
    out.push_str("        use serde::de::{self, Visitor};\n\n");
    out.push_str("        struct MaterialNameVisitor;\n\n");
    out.push_str("        impl<'de> Visitor<'de> for MaterialNameVisitor {\n");
    out.push_str("            type Value = MaterialName;\n\n");
    out.push_str("            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {\n");
    out.push_str("                formatter.write_str(\"a material name (e.g., 'sand', 'water') or numeric ID\")\n");
    out.push_str("            }\n\n");
    out.push_str("            fn visit_str<E>(self, value: &str) -> Result<MaterialName, E>\n");
    out.push_str("            where\n");
    out.push_str("                E: de::Error,\n");
    out.push_str("            {\n");
    out.push_str("                MaterialName::from_str(value).map_err(de::Error::custom)\n");
    out.push_str("            }\n\n");
    out.push_str("            fn visit_u64<E>(self, value: u64) -> Result<MaterialName, E>\n");
    out.push_str("            where\n");
    out.push_str("                E: de::Error,\n");
    out.push_str("            {\n");
    out.push_str("                MaterialName::try_from(value as u16)\n");
    out.push_str("                    .map_err(|id| de::Error::custom(format!(\"Unknown material ID: {}\", id)))\n");
    out.push_str("            }\n\n");
    out.push_str("            fn visit_i64<E>(self, value: i64) -> Result<MaterialName, E>\n");
    out.push_str("            where\n");
    out.push_str("                E: de::Error,\n");
    out.push_str("            {\n");
    out.push_str("                if value < 0 {\n");
    out.push_str("                    return Err(de::Error::custom(format!(\"Material ID cannot be negative: {}\", value)));\n");
    out.push_str("                }\n");
    out.push_str("                self.visit_u64(value as u64)\n");
    out.push_str("            }\n");
    out.push_str("        }\n\n");
    out.push_str("        deserializer.deserialize_any(MaterialNameVisitor)\n");
    out.push_str("    }\n");
    out.push_str("}\n\n");

    // MaterialName::all() method
    out.push_str("impl MaterialName {\n");
    out.push_str("    /// Get the numeric material ID\n");
    out.push_str("    pub fn id(self) -> u16 {\n");
    out.push_str("        self as u16\n");
    out.push_str("    }\n\n");
    out.push_str("    /// Get all material names\n");
    out.push_str("    pub fn all() -> &'static [MaterialName] {\n");
    out.push_str("        &[\n");

    for mat in materials {
        let pascal = to_pascal_case(&mat.name);
        out.push_str(&format!("            MaterialName::{},\n", pascal));
    }

    out.push_str("        ]\n");
    out.push_str("    }\n\n");

    // count() method
    out.push_str("    /// Get the total number of materials\n");
    out.push_str("    pub const fn count() -> usize {\n");
    out.push_str(&format!("        {}\n", materials.len()));
    out.push_str("    }\n");
    out.push_str("}\n\n");

    // Tests
    out.push_str("#[cfg(test)]\n");
    out.push_str("mod generated_tests {\n");
    out.push_str("    use super::*;\n\n");

    out.push_str("    #[test]\n");
    out.push_str("    fn test_material_name_roundtrip() {\n");
    out.push_str("        for &mat in MaterialName::all() {\n");
    out.push_str("            let id: u16 = mat.into();\n");
    out.push_str("            let back = MaterialName::try_from(id).unwrap();\n");
    out.push_str("            assert_eq!(mat, back);\n");
    out.push_str("        }\n");
    out.push_str("    }\n\n");

    out.push_str("    #[test]\n");
    out.push_str("    fn test_material_name_from_str() {\n");
    out.push_str(
        "        assert_eq!(MaterialName::from_str(\"sand\").unwrap(), MaterialName::Sand);\n",
    );
    out.push_str(
        "        assert_eq!(MaterialName::from_str(\"SAND\").unwrap(), MaterialName::Sand);\n",
    );
    out.push_str(
        "        assert_eq!(MaterialName::from_str(\"Sand\").unwrap(), MaterialName::Sand);\n",
    );
    out.push_str("    }\n\n");

    out.push_str("    #[test]\n");
    out.push_str("    fn test_material_name_display() {\n");
    out.push_str("        assert_eq!(MaterialName::Sand.to_string(), \"sand\");\n");
    out.push_str("        assert_eq!(MaterialName::SoapyWater.to_string(), \"soapy_water\");\n");
    out.push_str("    }\n");

    out.push_str("}\n");

    out
}
